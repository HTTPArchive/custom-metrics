// Note: Using prefixed variable to avoid naming collisions in the global scope.
// This name must exactly match the one referenced in custom metrics.
const httparchive_observers = {
  call_stacks: {},
  function_values: {},
};
let httparchive_enable_observations = false;

// Local scope.
(() => {
  // Additional logging.
  const DEBUG_MODE = false;

  // Add the pathnames of any functions/properties you want to observe.
  const OBSERVERS = [
    "Object.toString", // only works if calling the static method
    "navigator.scheduling", // TODO: doesn't work
    "navigator.scheduling.isInputPending", // TODO: only supports one dot notation
  ];

  const PROPERTIES_TO_TRACE = new Set([
    "navigator.userAgent",
    "navigator.vendor",
    "OfflineAudioContext",
    "OfflineAudioContext.prototype.createOscillator",
    "OfflineAudioContext.prototype.createDynamicsCompressor",
    "HTMLCanvasElement.prototype.getContext",
    "HTMLCanvasElement.prototype.toDataURL",
  ]);

  // for each observer: custom function to determine which part of the argument should be captured
  const FUNCTION_CALL_ARGUMENTS_TO_CAPTURE = {
    matchMedia: function (mediaQueryString) {
      const match = mediaQueryString.match(/\(([^:)]+)[:)]/);
      if (match) {
        return match[1];
      }
      return null;
    },
  };

  function resolveObject(pathname) {
    let obj = window;
    let props = pathname.split(".");

    while (props.length) {
      if (!obj) {
        return null;
      }

      const prop = props.shift();
      obj = obj[prop];
    }

    return obj || null;
  }

  function getAllProperties(pathname, depth = 1) {
    if (!depth) {
      return pathname;
    }

    const props = pathname.split(".");
    const parentPathname = props.slice(0, -1).join(".");
    const parentObj = resolveObject(parentPathname);

    try {
      return Object.getOwnPropertyNames(parentObj).flatMap((prop) => {
        return getAllProperties(`${parentPathname}.${prop}`, depth - 1);
      });
    } catch (e) {
      if (DEBUG_MODE) {
        console.debug(
          `Cannot get property names of ${parentPathname}, parent object: ${parentObj}, error: ${e}`
        );
      }
      return pathname;
    }
  }

  function initializeObserver(pathname) {
    const props = pathname.split(".");
    const prop = props.at(-1);
    const parentPathname = props.slice(0, -1).join(".");

    let parentObj = window[parentPathname];
    if (parentPathname) {
      pathname = `${parentPathname}.${prop}`;
      parentObj = resolveObject(parentPathname);
    }

    try {
      original = parentObj[prop];
    } catch (e) {
      // The property is not accessible.
      if (DEBUG_MODE) {
        console.debug(`${pathname} is not accessible: ${e}`);
      }
      return;
    }

    try {
      const proxy = new Proxy(parentObj, {
        get: function (target, key) {
          // debugger;
          if (key === prop) {
            console.log(`${key}: +1`);
          }
          return target[key];
        },
      });

      window[parentPathname] = proxy;
    } catch (e) {
      // The property is not observable.
      if (DEBUG_MODE) {
        console.debug(`${pathname} is not observable: ${e}`);
      }
      return;
    }

    if (PROPERTIES_TO_TRACE.has(pathname)) {
      httparchive_observers.call_stacks[pathname] = {};
    }

    if (pathname in FUNCTION_CALL_ARGUMENTS_TO_CAPTURE) {
      httparchive_observers.function_values[pathname] = {};
    }
    httparchive_observers[pathname] = 0;
  }

  OBSERVERS.forEach((pathname) => {
    if (pathname.split(".").at(-1) == "**") {
      getAllProperties(pathname, 3).forEach(initializeObserver);
      return;
    }

    if (pathname.split(".").at(-1) == "*") {
      getAllProperties(pathname).forEach(initializeObserver);
      return;
    }

    initializeObserver(pathname);
  });

  httparchive_enable_observations = true;
})();
